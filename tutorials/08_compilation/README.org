#+TITLE: The C Compilation

In these notes, we will look at the compilation process in detail.
When you write a C program, what you ultimately want is an executable
binary that your computer can run. The process of getting from
human-readable code to machine-executable code involves several
distinct stages, even though most modern compilers
automate them into a single command.


* Preprocessing
The first stage is the /preprocessor./ The preprocessor applies some
transformations to the source code base on some commands called
/directives./ The preprocessor directives are not normal C statements,
and they all begin with the =#= symbol. For example, consider the
following code in a file named =main.c=:

#+begin_src c
  #include <stdio.h>
  #define PI 3.14

  int main(void)
  {
      printf("pi is %f\n", PI);
  }
#+end_src

In the example code, both =#include= and =#define= are preprocessor
directives.  The output of the C preprocessor is some raw C code with
the directives resolved. For example, you can invoke the preprocessor
with the following command:

#+begin_src shell
  gcc -E main.c -o main.i
#+end_src

If you look at the content of the =main.i= file, you will see that
every occurrence of =PI= has been replaced with =3.14=, and there will
be a long header with many function declarations at the beginning. The
header at the beginning of the file is the content of the =stdio.h=
file that replaces the =#include <stdio.h>= directive. Now, let's view
some of these directives.

** Macro Definitions
An essential feature of the preprocessor is the ability to define
macros using the =#define= directive. Macros allow you to create
symbolic names or inline code snippets. For example, =#define PI 3.14=
defines =PI= as a constant value. Every time the preprocessor sees =PI=,
it replaces it with =3.14=. Additionally, macros can also act like
functions. For example, consider the following code:

#+begin_src c
  #include <stdio.h>
  #define MIN(x, y) x > y ? y : x

  int main(void)
  {
      printf("min(%d, %d) = %d\n", 1, 2, MIN(1, 2));
  }
#+end_src

This macro takes two arguments and returns the minimum. In practice,
it takes every occurrence of =MIN(x, y)= and replaces it with =x > y ?
y : x=. For example, the =printf= line will look as follows after the
preprocessor passes:

#+begin_src c
  printf("min(%d, %d) = %d\n", 1, 2, 1 > 2 ? 2 : 1);
#+end_src

Compared to functions, macros are faster because they do not include in
function call overhead (calling a function has a small negligible
overhead), but they can be tricky to debug since their output might
not be what you expect. For example, let's change the code from before
as follows:

#+begin_src c
  #include <stdio.h>
  #define MIN(x, y) x > y ? y : x

  int main(void)
  {
      printf("1 + min(%d, %d) = %d\n", 1, 2, 1 + MIN(1, 2));
  }
#+end_src

One could expect that the correct result is =2=, but in reality the
code above will output =1=, but why? We can understand the issue easily
by looking at the code generated by the macro. After macro expansion,
the =printf= line will look as follows:

#+begin_src c
  printf("min(%d, %d) + 1 = %d\n", 1, 2, 1 + 1 > 2 ? 2 : 1);
#+end_src

If we look at the precedence of operators, the =+= is evaluated first,
so the conditional will be false, and the whole expression will return
=1=. We can fix the precedence issue by inserting some parentheses as
follows:

#+begin_src c
  #include <stdio.h>
  #define MIN(x, y) ((x) > (y) ? (y) : (x))

  int main(void)
  {
      printf("1 + min(%d, %d) = %d\n", 1, 2, 1 + MIN(1, 2));
  }
#+end_src

In general, when defining some operation prefer using normal functions
to macros. The runtime cost of a function is negligible most of the
times, and the compiler is able to optimize your code.


If you want to remove a previously defined macro, you can use the
=#undef= directive. This can be useful in larger projects where
different files may use the same macro names for different
purposes. By undefining a macro, you prevent it from interfering with
the rest of your code.

Two advanced but powerful features of macros are /stringizing/ and /token
pasting./ Stringizing, achieved with the =#= operator, turns a macro
parameter into a string. For example, consider the following macro:

#+begin_src c
  #define STRING(x) #x
#+end_src c

The invocation of the =STRING(hello)= macro results into the string
="hello"=.

Token pasting uses the =##= operator to concatenate tokens. For
example, consider the following macro:

#+begin_src c
  #define MAKE_VAR(name, num) name##num
#+end_src c

The invocation of the =MAKE_VAR(var, 1)= macro results into =var1=,
which can be used as a variable name.

The C Preprocessor also defines some predefined macros that give useful
information about the current file and compilation environment. Some of the
most used macros are the following:

  - =__FILE__=. This macro expands to the name of the current input
    file, in the form of a C string constant. This is the path by
    which the preprocessor opened the file, not the short name
    specified in =#include= or as the input file name argument. For
    example, =/usr/local/include/myheader.h= is a possible expansion
    of this macro.
  - =__LINE__=. This macro expands to the current input line number,
    in the form of a decimal integer constant. While we call it a
    predefined macro, itâ€™s a pretty strange macro, since its
    definition changes with each new line of source code.
  - =__DATE__=. This macro expands to a string constant that describes
    the date on which the preprocessor is being run. The string
    constant contains eleven characters and looks like "Feb 12
    1996". If the day of the month is less than 10, it is padded with
    a space on the left.
  - =__TIME__=. This macro expands to a string constant that describes
    the time at which the preprocessor is being run. The string
    constant contains eight characters and looks like "23:59:01".
  - =__STDC__=. In normal operation, this macro expands to the
    constant 1, to signify that this compiler conforms to ISO Standard
    C.

These macros are especially helpful for debugging and logging. For
instance, printing =__FILE__= and =__LINE__= can help you track where
errors occur in large codebases.

** Conditional Compilation
The C Preprocessor also allows you to include or exclude parts of your
code based on conditions. This is especially useful for writing
platform-independent code or enabling/disabling debug output. The main
directives used here are =#ifdef=, =#ifndef=, =#if=, =#elif=, =#else=,
and =#endif=.  For example, consider the following code:

#+begin_src c
  #ifdef DEBUG
    printf("Debug mode\n");
  #endif
#+end_src

This snippet only compiles the =printf= line if the macro =DEBUG= is
defined. Similarly, you can use =#ifndef= to check if a macros is not
defined and avoid duplicate definitions.  You can also use conditional
expressions such as:

#+begin_src c
  #if VALUE > 10
    printf("value > 10\n");
  #elif VALUE <= 10 && VALUE > 0
    printf("value is positive\n");
  #else
    printf("value is not positive\n");
  #endif
#+end_src

Notice that these conditionals are evaluated at compile time and not
at runtime.

** File Inclusion
One of the most common tasks performed by the preprocessor is file
inclusion, handled by the =#include= directive. This is used to
include the contents of another file into your source code. If you use
angle brackets, as in =#include <stdio.h>=, the compiler looks for the
file in the standard system directories. If you use double quotes,
like =#include "myheader.h"=, it first looks in the current directory,
and then in the standard paths.

This mechanism is what makes it possible to modularize code by
dividing it into multiple files, and to reuse common functionality
provided in libraries.

A header file is a file containing definitions of functions,
variables, and macros that are shared among multiple source files.
For example, the file =main.i= shows the content of the =stdio.h= file
in its beginning. However, when you include a header file multiple
times (directly or indirectly), it can lead to duplicate definitions
and compiler errors. To prevent this, developers use include
guards. These are conditional directives that ensure a header file's
contents are only included. For example, consider defining the
=myheader.h= header file, the typical pattern for its content is the
following:

#+begin_src c
  // We first check if we have not included the definitions contained
  // in this header file.
  #indef MY_HEADER_H_INCLUDED
  // If we have not, we define a macro indicating that we have
  // already included this header.
  #define MY_HEADER_H_INCLUDED

  // Insert your declarations here.

  #endif
#+end_src


* Compilation
The compiler takes the preprocessed C code and translates it into
/assembly code./ The assembly language is a programming language that
is specific to the machine you will be running your program on.
Therefore, it is not an high level language like C anymore.  This step
is quite complex, and involves many checks such as ensuring that the
program respects the rules of the C programming language.  You can
invoke the compiler on the example program as follows:

#+begin_src shell
  gcc -S main.i -o main.s
#+end_src

The content of the =main.s= will still be textual, so you can still
examine its contents, but it will really depend on the machine you are
targeting.

* Assembly
The assembler takes the assembly code and turns it into machine code
in the form of an /object file./ This file is not yet executable -- it
may be missing other components like external functions which will be
solved in later stages of the compilation process. An object file is
already machine code. Differently from the output of the previous
stages, it is more difficult to examine.  You can invoke assembler on
our example program as follows:

#+begin_src shell
  gcc -c main.s -o main.o
#+end_src

* Linking
The final step of the compilation process is the /linking./ The linker
combines one or more object files, often producing a final executable
file.  It resolves references to external symbols. An example of an
external symbol is the =printf= function. As you can see from the
=main.i= file, there is a declaration, but no definition of the
=printf= function. Therefore, how do you decide what code should be
executed?  It is the linker that solves these symbols mapping them to
their implementation.  Finally, you can invoke the linker as follows
and produce an executable.

#+begin_src shell
  gcc main.o -o main
#+end_src

Note that only now you can execute the =main= program.
